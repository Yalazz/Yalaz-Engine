#version 450
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rgba32f) uniform writeonly image2D outImage;

// Push constants - matches C++ PathTracePushConstants (208 bytes)
layout(push_constant) uniform PushConstants {
    mat4 invView;           // 64 bytes
    mat4 invProjection;     // 64 bytes
    vec4 cameraPos;         // 16 bytes (xyz = pos, w = unused)
    vec4 sunlightDir;       // 16 bytes (xyz = direction, w = intensity)
    vec4 sunlightColor;     // 16 bytes
    vec4 ambientColor;      // 16 bytes (rgb = color, a = intensity)
    uint frameIndex;        // 4 bytes
    uint padding[3];        // 12 bytes for alignment
} pc;

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outImage);

    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y)
        return;

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(imageSize) * 2.0 - 1.0;
    uv.y *= -1.0;

    // Kamera ışını üretimi
    vec4 rayClip = vec4(uv, -1.0, 1.0);
    vec4 rayView = pc.invProjection * rayClip;
    rayView = vec4(rayView.xyz / rayView.w, 0.0);
    vec3 rayDir = normalize((pc.invView * rayView).xyz);
    vec3 rayOrigin = pc.cameraPos.xyz;

    // Küre ile çarpışma testi
    vec3 sphereCenter = vec3(0.0, 0.0, -5.0);
    float radius = 1.0;
    vec3 oc = rayOrigin - sphereCenter;

    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    vec3 color = vec3(0.0);

    if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.001) {
            vec3 hitPos = rayOrigin + t * rayDir;
            vec3 normal = normalize(hitPos - sphereCenter);

            vec3 lightDir = normalize(pc.sunlightDir.xyz);
            float lambert = max(dot(normal, lightDir), 0.0);
            vec3 lightColor = pc.sunlightColor.rgb * pc.sunlightDir.w;

            color = lambert * lightColor;
            color += pc.ambientColor.rgb * pc.ambientColor.a;
        }
    } else {
        // Sky rengi (gökyüzü gradient)
        color = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.3, 0.4), uv.y);
    }

    imageStore(outImage, pixelCoord, vec4(color, 1.0));
}
